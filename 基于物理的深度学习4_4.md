# 可微分流体模拟

## 目录
- 物理模型
- 问题表述
- 开始实现
- 批处理模拟
- 梯度计算
- 优化过程
- 重新模拟
- 结论
- 后续步骤

我们现在以一个更复杂的例子为目标，使用 Navier-Stokes 方程作为物理模型。与 **Navier-Stokes 前向模拟** 一致，我们将针对一个 2D 案例。

作为优化目标，我们将考虑先前 Burgers 示例的一个更困难的变体：观测到的密度状态应在 $n = 20$ 步模拟后匹配给定的目标。与之前不同的是，以标记场 $s$ 形式存在的观测量不能以任何方式改变。只有速度 $u_0$ 在 $t = 0$ 时的初始状态可以被修改。这为损失公式的观测量和我们在优化期间（或后来通过神经网络）可以交互的量之间提供了分离。[在 colab 中运行]

[返回顶部]

## 物理模型

我们将使用一个无粘性的 Navier-Stokes 模型，速度为 $u$，没有显式的粘性项，并且有一个烟雾标记密度 $s$，它驱动一个简单的 Boussinesq 浮力项，沿 y 维度添加一个力 $\eta_d$。由于缺乏显式粘度，这些方程等同于欧拉方程。这给出：

$$
\begin{aligned}
\frac{\partial u_x}{\partial t} + u \cdot \nabla u_x &= -\frac{1}{\rho} \nabla p \\
\frac{\partial u_y}{\partial t} + u \cdot \nabla u_y &= -\frac{1}{\rho} \nabla p + \eta_d \\
\text{s.t.} \quad \nabla \cdot u &= 0,
\end{aligned}
$$

加上一个用于被动平流的标记密度 $s$ 的额外输运方程：

$$
\frac{\partial s}{\partial t} + u \cdot \nabla s = 0
$$

（

问题背景

- 我们要解的还是一个 **重构问题**：
   已知某个物理场在 **第 20 步模拟之后的观测状态**（也就是 $t$ 时刻的密度分布 $s$）。
   我们希望通过优化 **初始速度场 $u_0$**，使得经过 20 步物理演化之后，模拟结果和这个目标观测尽量一致。
- 关键限制：
  - **观测量 $s$**（烟雾/标记密度场）是给定的，不能随意修改。
  - 只有初始速度场 $u_0$ 是可调的。

👉 这就把 **可以直接优化的量（速度）** 和 **只能被观测的量（密度）** 区分开了。

）

（

- 你可以把这个模型想象成一间房间里有一股烟雾：
  - 初始时刻你可以“设计”空气的速度分布（这就是我们要优化的 $u_0$）。
  - 然后让烟雾随空气流动 20 个时间步。
  - 目标是让烟雾在 20 步后形成某个特定的形状（观测数据）。
- **约束条件**：
  - 烟雾本身 $s$ 不能随意改，只能随着流动走。
  - 我们能控制的唯一“旋钮”就是初始速度场。

👉 所以这是一个 **逆向问题**：已知终点（烟雾分布），反推出起点的速度场。

）

## 问题表述

使用 **模型与方程** 中的符号，上面概述的逆向问题可以表述为一个最小化问题

$$
\arg \min_{u_0} \sum_i (f(x_{t_e,i}; u_0) - y^*_{t_e,i})^2,
$$

其中 $y^*_{t_e,i}$ 是目标时间 $t_e$ 处参考解的样本，$x_{t_e,i}$ 表示我们的模拟器在同一采样位置和时间的估计值。这里的索引 $i$ 遍历我们流体求解器中所有离散化的空间自由度（我们下面将有 $32 \times 40$）。

与之前相比，我们不再处理预先计算的量，而是现在 $x_{t_e,i}$ 本身就是一个复杂的非线性函数。更具体地说，模拟器从初始速度 $u_0$ 和密度 $s_0$ 开始，通过评估离散化的 PDE $P$ 来计算 $x_{t_e,i}$。这给出模拟的最终状态 $y_{t_e,i} = s_{t_e} = P^n(u_0, s_0)$，在下面我们将保持 $s_0$ 固定，并专注于 $u_0$ 作为我们的自由度。因此，优化只能改变 $u_0$ 以尽可能与参考 $y^*_{t_e,i}$ 对齐。

## 开始实现

首先，让我们先处理好 Python 模块的加载。通过导入 `phi.torch.flow`，我们获得了可以在 pytorch 图中工作并提供梯度的流体模拟函数（`phi.tf.flow` 是 tensorflow 的替代方案）。

```python
!pip install --upgrade --quiet phiflow==3.4
from phi.torch.flow import *
import pylab # 用于后续可视化
```

## 批处理模拟

现在我们可以建立模拟，这将与 **Navier-Stokes 前向模拟** 中先前的“常规”模拟示例一致地工作。但是，现在我们将直接包含一个额外的维度，类似于用于 NN 训练的小批量（mini-batch）。为此，我们将引入一个名为 `inflow_loc` 的命名维度。该维度将“位于”先前的空间维度 `y`, `x` 之上，这些空间维度被声明为向量通道的维度。正如名称 `inflow_loc` 所示，此维度的主要区别在于流入（inflow）的不同位置，以便获得不同的流动模拟。Phiflow 中的命名维度使得在不同张量的匹配维度之间广播信息非常方便。

最后一条语句验证了我们的 `INFLOW` 网格除了空间维度 `x` 和 `y` 之外还有一个 `inflow_loc` 维度。您可以使用 `.exists` 布尔值测试张量维度是否存在，它可以针对任何维度名称进行评估。例如，上面的 `INFLOW.inflow_loc.exists` 将给出 `True`，而 `INFLOW.some_unknown_dim.exists` 将给出 `False`。上标 `ᵇ` 表示 `inflow_loc` 是一个批处理维度。

Phiflow 张量通过其名称自动广播到新维度，因此通常不需要重塑（reshape）操作。例如，您可以轻松地添加或乘具有不同维度的张量。下面我们将一个交错网格（staggered grid）与一个沿着 `inflow_loc` 维度且值为 1 的张量相乘，通过 `StaggeredGrid(...) * math.ones(batch(inflow_loc=4))` 得到一个具有 `x,y,inflow_loc` 维度的交错速度。

```python
# 封闭域
INFLOW_LOCATION = tensor([(12, 4), (13, 6), (14, 5), (16, 5)], batch('inflow_loc'), channel('vector')) # 流入位置
INFLOW = (1./3.) * CenteredGrid(Sphere(center=INFLOW_LOCATION, radius=3), extrapolation.BOUNDARY, x=32, y=40, bounds=Box(x=(0,32), y=(0,40))) # 流入场
BND = extrapolation.ZERO # 封闭，下面速度网格的边界条件

# 取消注释以获得一个稍有不同的开放域情况
#INFLOW_LOCATION = tensor([(11, 6), (12, 4), (14, 5), (16, 5)], batch('inflow_loc'), channel('vector'))
#INFLOW = (1./4.) * CenteredGrid(Sphere(center=INFLOW_LOCATION, radius=3), extrapolation.BOUNDARY, x=32, y=40, bounds=Box(x=(0,32), y=(0,40)))
#BND = extrapolation.BOUNDARY # 开放边界

INFLOW.shape
# 输出: (inflow_locᵇ=4, xˢ=32, yˢ=40)
```

我们现在可以轻松地模拟几步，从这些不同的初始条件开始。得益于广播，我们在概述章节中用于单次前向模拟的完全相同代码将产生四个具有不同烟雾流入位置的模拟。

```python
smoke = CenteredGrid(0, extrapolation.BOUNDARY, x=32, y=40, bounds=Box(x=(0,32), y=(0,40))) # 初始烟雾
velocity = StaggeredGrid(0, BND, x=32, y=40, bounds=Box(x=(0,32), y=(0,40))) # 相同的初始速度 0

def step(smoke, velocity):
    smoke = advect.mac_cormack(smoke, velocity, dt=1) + INFLOW
    buoyancy_force = (smoke * (0, 1)).at(velocity) # 浮力 force
    velocity = advect.semi_lagrangian(velocity, velocity, dt=1) + buoyancy_force
    velocity, _ = fluid.make_incompressible(velocity, [], Solve('CG', 1e-3, rank_deficiency=1e3, suppress=('x', 'y'))) # 不可压求解
    return smoke, velocity

for _ in range(20):
    smoke,velocity = step(smoke,velocity)

# 存储并显示最终状态（优化前）
smoke_final = smoke
fig, axes = pylab.subplots(1, 4, figsize=(10, 6))
for i in range(INFLOW.shape.get_size('inflow_loc')):
    axes[i].imshow(smoke_final.values.numpy('inflow_loc,y,x')[i,...], origin='lower', cmap='magma')
    axes[i].set_title(f"Inflow {INFLOW_LOCATION.numpy('inflow_loc,vector')[i]}" + (", Ref." if i==3 else ""))
pylab.tight_layout()
```

最后的图像显示了 20 个模拟步骤后平流烟雾场的状态。流入位于 (16,5) 的模拟 [3] 的最终烟雾形状（最右边的直羽流）将是我们下面的参考状态。其他三个的初始速度将在下面的优化过程中进行修改以匹配此参考。

（作为一个小提示：上面的不可压求解需要额外的标志来防止 CG 求解器因缺乏收敛而抛出异常。在像这样的优化和学习任务中可能会发生这种情况，`rank_deficiency` 和 `suppress` 参数为 phiflow 压力求解实现了这一点。此外，phiflow 张量将使用创建它们的后端来跟踪它们的操作链。例如，使用 NumPy 创建的张量将继续使用 NumPy/SciPy 操作，除非将 PyTorch 或 TensorFlow 张量也传递给同一操作。因此，最好时不时验证张量是否使用了正确的后端，例如通过 `GRID.values.default_backend`。）

（

依然没有神经网络

这段代码演示了：

- 如何在同一段模拟代码里同时处理多个实验条件（不同流入口）。
- 烟雾如何被注入、随速度流动，并受到浮力作用。
- 经过 20 步后，每个初始条件都会得到不同的烟雾形状。
- 我们会选择其中一个作为“目标”，用来测试后续的优化（调整初始速度，使别的入口流动结果逼近目标）。

）

## 梯度计算

让我们看看如何从我们的模拟中获取梯度。上面处理的第一个简单步骤是包含 `phi.torch.flow` 以导入可微分算子来构建我们的模拟器。

（

#### 计算梯度

```
sim_grad = field.gradient(simulate, wrt=[1], get_output=False)
(velocity_grad,) = sim_grad(initial_smoke, initial_velocity)
```

- `field.gradient()`：自动构建一个函数，能算出损失对输入的梯度。
- `wrt=[1]`：表示我们只对 `simulate` 的第二个参数（速度）求导。
- 输出 `velocity_grad` 的形状和初始速度一样：四个批次、交错网格。

）

现在我们要优化初始速度，以便所有模拟都达到与右侧模拟相似的最终状态，其中流入位于 (16, 5)，即沿 x 居中。为了实现这一点，我们在模拟期间记录梯度并定义一个简单的基于 $L_2$ 的损失函数。我们将使用的损失函数由 $L = |s_{t_e} - s^*_{t_e}|^2$ 给出，其中 $s_{t_e}$ 表示烟雾密度，$s^*_{t_e}$ 表示我们批次中第四个模拟的参考状态（两者都在最后时间步 $t_e$ 评估）。在评估损失函数时，我们通过 `field.stop_gradient()` 将参考状态视为外部常数。正如顶部概述的那样，$s$ 是 $u$ 的函数（通过平流方程），而 $u$ 又由 Navier-Stokes 方程给出。因此，通过多个时间步的链，$s$ 依赖于初始速度状态 $u_0$。

重要的是，在我们记录梯度之前，我们的初始速度具有 `inflow_loc` 维度，这样我们就有了完整的四版本速度的“小批量”（其中三个将在我们稍后的优化中通过梯度更新）。为了获得适当的速度张量，我们用一个沿着 `inflow_loc` 批处理维度且值为零的张量初始化一个 `StaggeredGrid`。由于交错网格已经有 y、x 和向量维度，这给出了所需的四个维度，如下面的打印语句所验证。

Phiflow 通过使用需要返回损失值以及可选状态值的函数，为不同平台提供了统一的梯度 API。它使用基于损失函数的接口，为此我们在下面定义了 `simulate` 函数。`simulate` 计算上面概述的 $L_2$ 误差，并在 20 个模拟步骤后返回演化后的烟雾和速度状态。

```python
initial_smoke = CenteredGrid(0, extrapolation.BOUNDARY, x=32, y=40, bounds=Box(x=(0,32), y=(0,40))) # 初始烟雾
initial_velocity = StaggeredGrid(math.zeros(batch(inflow_loc=4)), BND, x=32, y=40, bounds=Box(x=(0,32), y=(0,40))) # 初始速度 (4个批次，全为0)
print("Velocity dimensions: "+format(initial_velocity.shape))
# 输出: Velocity dimensions: (inflow_locᵇ=4, xˢ=32, yˢ=40, vectorᶜ=x,y)

def simulate(smoke: CenteredGrid, velocity: StaggeredGrid):
    for _ in range(20):
        smoke,velocity = step(smoke,velocity)
    loss = field.l2_loss(smoke - field.stop_gradient(smoke.inflow_loc[-1]) ) # 计算与最后一个（参考）的L2损失
    # 可选地，使用带扩散步骤的更平滑的损失 - 这里没有区别，但有时有用
    #loss = field.l2_loss(diffuse.explicit(smoke - field.stop_gradient(smoke.inflow_loc[-1]), 1, 1, 1))
    return loss, smoke, velocity
```

Phiflow 的 `field.gradient()` 函数是计算梯度的核心函数。接下来，我们将使用它来获得关于初始速度的梯度。由于速度是 `simulate()` 函数的第二个参数，我们传递 `wrt=[1]`。（Phiflow 还有一个 `field.spatial_gradient` 函数，它改为计算张量沿空间维度（如 x, y）的导数。）

`gradient` 生成一个梯度函数。作为演示，下一个单元格使用烟雾和速度的初始状态评估梯度一次。最后一条语句打印了结果梯度张量的一部分摘要。

```python
sim_grad = field.gradient(simulate, wrt=[1], get_output=False)
(velocity_grad,) = sim_grad(initial_smoke, initial_velocity)
print("Some gradient info: " + format(velocity_grad))
print(format(velocity_grad.values.inflow_loc[0].vector[0])) # 一个例子，位置 [0] 的 x 分量
# 输出: 
# Some gradient info: StaggeredGrid[(inflow_locᵇ=4, xˢ=32, yˢ=40, vectorᶜ=x,y), size=(x=31.5, y=40), data=(xˢ=31, yˢ=40) 2.61e-08 ± 8.5e-01 (-2e+01...1e+01)
# (xˢ=32, yˢ=40) 0.00e+00 ± 0.00e+00 (0e+00...0e+00)  (示例输出，具体值可能不同)
```

最后两行只是打印了关于结果梯度场的一些信息。自然，它具有与速度本身相同的形状：它是一个具有四个流入位置的交错网格。最后一行显示了如何访问其中一个梯度的 x 分量。

我们可以使用常规绘图函数查看计算的梯度内容，例如，通过 `velocity_grad.values.inflow_loc[0].vector[0].numpy('y,x')` 将一个模拟的 x 分量转换为 numpy 数组。一个交互式替代方案是 phiflow 的 `view()` 函数，它会自动分析网格内容并提供 UI 按钮来选择不同的查看模式。您可以使用它们显示箭头、二维速度矢量的单个分量或其大小。然而，由于其交互性，相应的图像不会在 Jupyter 之外显示，因此我们下面通过 `plot()` 显示矢量长度。

```python
# 简洁的 phiflow 辅助函数：
v = vis.plot(field.vec_length(velocity_grad)) # 显示大小
# <Figure size 864x360 with 5 Axes> (会显示一个包含5个子图的图形)
```

毫不奇怪，左边的第四个梯度为零（它已经匹配参考）。其他三个梯度检测到了初始圆形流入位置周围的变化，显示为正负区域。左边距离较大的那些也明显更大。

（

这一节展示了如何：

1. 用 **物理模拟器**（Navier–Stokes + 烟雾平流）构建一个复杂系统。
2. 定义一个 **损失函数**，比较多个模拟和参考解的末态。
3. 借助 **自动微分**，高效地算出损失对初始速度场的梯度。
4. 梯度揭示了应该如何调整初始速度，才能让最终结果更接近目标。

👉 这是 **可微分物理的核心魅力**：即使是复杂的 PDE 系统，我们也能自动拿到关于初始条件的优化方向。

）

## 优化过程

上面可视化的梯度只是指向损失增加方向的线性化变化。现在我们可以继续沿着相反方向更新初始速度以最小化损失，并迭代以找到最小化器。

这是一项艰巨的任务：由于不同的初始空间密度配置，模拟正在产生不同的动力学。我们的优化现在应该找到一个单一的初始速度状态，使得在 $t = 20$ 时产生与参考模拟相同的状态。因此，经过 20 个非线性更新步骤后，模拟应该重现所需的标记密度状态。简单地改变标记流入的位置来实现这个目标会容易得多，但是——为了让事情更困难、更有趣——流入不是一个自由度。优化器只能改变初始速度 $u_0$。

以下单元格实现了一个简单的最速梯度下降优化：它重新评估梯度函数，并迭代几次以使用学习率（步长）`LR` 进行优化。

`field.gradient` 有一个参数 `get_output`，它决定是返回函数的原始结果（在我们的例子中是 `simulate()`）还是仅返回梯度。由于跟踪损失在迭代过程中如何演变很有趣，让我们用 `get_output=True` 重新定义梯度函数。

```python
sim_grad_wloss = field.gradient(simulate, wrt=[1], get_output=True) # 如果我们还需要输出（如损失）
LR = 1e-03
for optim_step in range(80):
    (loss, _smoke, _velocity), (velocity_grad,) = sim_grad_wloss(initial_smoke, initial_velocity)
    initial_velocity = initial_velocity - LR * velocity_grad
    if optim_step<3 or optim_step%10==9: print('Optimization step %d, loss: %f' % (optim_step,loss))
# 输出示例:
# Optimization step 0, loss: 298.286163
# Optimization step 1, loss: 291.454376
# Optimization step 2, loss: 276.057831
# ...
# Optimization step 79, loss: 169.943680
```

损失应该已经从接近 300 显著下降到 170 以下，现在我们也可以可视化在优化中获得初始速度。

以下图像显示了产生的三个初始速度的 x 分量（第一组图像）和 y 分量（第二组图像）。我们跳过第四组 `inflow_loc[0]`，因为它只包含零。

```python
fig, axes = pylab.subplots(1, 3, figsize=(10, 4))
for i in range(INFLOW.shape.get_size('inflow_loc')-1): # 跳过参考的最后一个
    im = axes[i].imshow(initial_velocity.staggered_tensor().numpy('inflow_loc,y,x,vector')[i,...,0], origin='lower', cmap='coolwarm') # x 分量
    axes[i].set_title(f"Ini. vel. X {INFLOW_LOCATION.numpy('inflow_loc,vector')[i]}")
    pylab.colorbar(im,ax=axes[i])
pylab.tight_layout()

fig, axes = pylab.subplots(1, 3, figsize=(10, 4))
for i in range(INFLOW.shape.get_size('inflow_loc')-1): # 跳过参考的最后一个
    im = axes[i].imshow(initial_velocity.staggered_tensor().numpy('inflow_loc,y,x,vector')[i,...,1], origin='lower', cmap='coolwarm') # y 分量
    axes[i].set_title(f"Ini. vel. Y {INFLOW_LOCATION.numpy('inflow_loc,vector')[i]}")
    pylab.colorbar(im,ax=axes[i])
pylab.tight_layout()
```

## 重新模拟

我们还可以可视化在给定每个流入位置的新初始速度条件的情况下，经过 20 步的完整模拟结果。这是在优化期间每次梯度计算内部发生的事情，也是我们的损失函数所测量的。因此，了解优化找到了哪些解决方案是很好的。

下面，我们使用来自 `initial_velocity` 的新初始条件重新运行前向模拟：

```python
smoke = initial_smoke
velocity = initial_velocity
for _ in range(20):
    smoke,velocity = step(smoke,velocity)

fig, axes = pylab.subplots(1, 4, figsize=(10, 6))
for i in range(INFLOW.shape.get_size('inflow_loc')):
    axes[i].imshow(smoke.values.numpy('inflow_loc,y,x')[i,...], origin='lower', cmap='magma')
    axes[i].set_title(f"Inflow {INFLOW_LOCATION.numpy('inflow_loc,vector')[i]}" + (", Ref." if i==3 else ""))
pylab.tight_layout()
```

自然，右边的图像是相同的（这是参考），其他三个模拟现在显示出向右移动的趋势。由于差异有点细微，让我们可视化目标配置与不同最终状态之间的差异。

以下图像包含演化后的模拟密度与目标密度之间的差异。因此，暗色区域表示目标应该是但没有达到的地方。顶行显示初始速度为零的原始状态，而底行显示优化调整初始速度后的版本。因此，在每一列中，您可以比较之前（顶部）和之后（底部）：

```python
fig, axes = pylab.subplots(2, 3, figsize=(10, 6))
for i in range(INFLOW.shape.get_size('inflow_loc')-1): # 前三列是待优化的
    im = axes[0,i].imshow(smoke_final.values.numpy('inflow_loc,y,x')[i,...] - smoke_final.values.numpy('inflow_loc,y,x')[3,...], origin='lower', cmap='coolwarm', vmin=-0.5, vmax=0.5) # 原始差异 (优化前)
    axes[0,i].set_title(f"Org. diff. {INFLOW_LOCATION.numpy('inflow_loc,vector')[i]}")
    pylab.colorbar(im,ax=axes[0,i])

for i in range(INFLOW.shape.get_size('inflow_loc')-1): # 前三列是优化后的
    im = axes[1,i].imshow(smoke.values.numpy('inflow_loc,y,x')[i,...] - smoke_final.values.numpy('inflow_loc,y,x')[3,...], origin='lower', cmap='coolwarm', vmin=-0.5, vmax=0.5) # 优化后差异
    axes[1,i].set_title(f"Result {INFLOW_LOCATION.numpy('inflow_loc,vector')[i]}")
    pylab.colorbar(im,ax=axes[1,i])
```

这些差异图像清楚地表明，优化成功地将羽流的上部区域对齐得很好。每个原始图像（顶部）在黑色光晕方面显示出明显的错位，而优化后的状态在很大程度上与参考的目标烟雾配置重叠，并且每个烟雾云前部的差异更接近于零。

请注意，所有三个模拟都需要“处理”固定的流入，因此它们不能简单地“无中生有”地产生标记密度来匹配目标。此外，每个模拟都需要考虑非线性模型方程如何在 20 个时间步的过程中改变系统的状态。因此，优化目标相当困难，并且在这种情况下不可能完全满足匹配参考模拟的约束。例如，这在烟雾羽流的茎部是可见的，在优化后仍然显示黑色光晕。优化无法改变流入位置，因此需要专注于对齐羽流的上部区域。

## 结论

这个例子说明了可微分物理方法如何可以轻松地扩展到更复杂的 PDE。上面，我们优化了一个完整 Navier-Stokes 求解器的 20 步小批量。😄

这是一个强大的基础，可以将神经网络引入画面。上面，自由度仍然是一个规则网格，我们联合解决了一个单一的逆向问题。当然，有三个案例要作为小批量解决，但尽管如此，该设置仍然代表直接优化。因此，与 **Burgers Optimization with a PINN** 的 PINN 示例一致，我们在这里并没有真正处理机器学习任务。然而，DP 训练允许与神经网络进行一系列灵活的组合，这将是下一章的主题。

## 后续步骤

基于上面的代码示例，我们建议尝试以下实验：

-   修改模拟的设置，使四个实例之间的差异更大，运行更长时间，或使用更精细的空间离散化（即更大的网格大小）。请注意，这将使优化问题更加困难，因此可能不会通过这种简单设置直接收敛。
-   作为一个更大的改变，添加多分辨率优化来处理具有较大差异的情况。即，首先用粗离散化求解，然后使用该解作为更精细离散化的初始猜测。